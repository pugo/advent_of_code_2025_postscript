%!PS-Adobe-3.0
%%BoundingBox: 24 24 571 818
%%Title: Advent of Code 2025 - day 9
%%For: Hackvalue
%%Creator: Anders Piniesjö
%%CreationDate: Mon Dec 13 22:47:41 2025
%%Orientation: Portrait
%%DocumentMedia: A4 595 842 0 () ()
%%EndComments

% -----------------------------------------------------------------------
%  Advent of Code 2025 in Postscript - Day 9
%  by Anders Piniesjö
%
%  Run with: ghostscript 9.ps
%  
%  -- Or print it on a Postscript printer!
% -----------------------------------------------------------------------

%% ----- Data -------

/input_data [
% <<INJECT DATA HERE>>
] bind def

%% ----- Output -------

/setup_output
{
   /stdout (%stdout) (w) file def
   /print { stdout exch writestring } bind def
   /println { print stdout (\n) writestring } bind def

   /LM   50 def      % Left margin
   /RM   578 def     % Right margin
   /TM   700 def     % Top margin
   /BM   10 def      % Bottom margin
   /fontsize 18 def  % Change this to change font-size
   /ypos TM def      % current y-position
   /lineheight fontsize def

   /font_normal /Times-Roman findfont fontsize scalefont def
   /font_bold /Times-Bold findfont fontsize scalefont def
   font_normal setfont
} def

/newline
 { currentpoint exch pop lineheight sub  % calc y-val
   BM lt                                 % check if less than bottom margin
   { showpage LM TM moveto               % New page
     /ypos TM def }
   { ypos lineheight sub                 % Go left/down
     /ypos exch def
     LM ypos moveto } ifelse
} def
   
/prtstr
 { dup stringwidth pop      % calc length of string
   currentpoint pop         % get horizontal position
   add RM gt                % sum > right margin?
   {newline} if             % if so, next line
   show 
} def

/setnormal { font_normal setfont } bind def
/setbold { font_bold setfont } bind def

%% ---- Utils ------

/min  %% int int -- int   | Return min of two ints
{
   2 copy gt { exch pop } { pop } ifelse
} bind def

/max  %% int int -- int   | Return max of two ints
{
   2 copy lt { exch pop } { pop } ifelse
} bind def

/append   %% array elem -- array with elem   | Append elem to array, returning a new array with result.
{
   1 index length dup 1 add array   % Create new larger array.
   dup 0 6 -1 roll putinterval      % Copy old array into new.
   dup 4 -2 roll                    % Duplicate array and stack roll.
   exch put                         % Put element to end.
} bind def

/deep_copy_stringarray  %% array -- array   | Deep copy an array of strings.
{
   /old exch def
   /new old length array def

   0 1 old length 1 sub
   {                       % i
      dup old exch get     % i str
      dup length string    % i str newstr
      0 3 -1 roll          % i newstr 0 str
      dup length 0 exch    % i newstr 0 str 0 slen
      getinterval          % i newstr 0 str
      2 index              % i newstr 0 str newstr
      5 1 roll             % newstr i newstr 0 str
      putinterval          % newstr i
      new exch 3 -1 roll   % new i 
      put    
   } for
   new
} bind def

/sort_array_sweep
{
   /s:swapcount 0 def
   dup length 2 sub
   0 1 3 -1 roll
   {
      /s:i exch def
      dup /s:a exch s:i get def
      dup /s:b exch s:i 1 add get def

      s:a null eq { /s:a 0 def } if
      s:b null eq { /s:b 0 def } if

      s:a s:b gt
      {
         dup s:i s:b put
         dup s:i 1 add s:a put
         /s:swapcount s:swapcount 1 add def
      } if
   } for
   pop  % pop array
   s:swapcount
} def

/sort_array  %% Array --  | Sorts the array with numbers
{
   /target exch def
   {
      target sort_array_sweep
      0 eq { exit } if
   } loop
} bind def

%% --- Polygon ----------

/p:init
{
   /p:horizontals [] def
   /p:verticals [] def
   /p:y_to_xranges 100000 dict def
   /p:x_to_yranges 100000 dict def
   /p:x_min 10e5 def
   /p:x_max 0 def
   /p:y_min 10e5 def
   /p:y_max 0 def
} bind def

/p:find_horizontals
{
   /p:data exch def
   /p:len p:data length def

   /p:start 0 def
   p:data 0 get 1 get p:data 1 get 1 get ne
   {
      % First two y coordintates not equal. Start on second number to get horizontals.
      /p:start 1 def
   } if

   /p:end p:start p:len add 1 sub def

   p:start 2 p:end
   {
      dup
      p:data exch get /p:a exch def 
      p:data exch 1 add p:len mod get /p:b exch def

      p:a 1 get         % Get y
      p:a 0 get         % Get x1
      p:b 0 get         % Fet x2
      2 copy min        % Find min of x1 and x2
      3 1 roll max      % Find max of x1 and x2
      3 array astore    % Make array [y x1 x2]

      p:horizontals exch append /p:horizontals exch def
   } for
} bind def

/p:find_verticals
{
   /p:data exch def
   /p:len p:data length def

   /p:start 0 def
   p:data 0 get 0 get p:data 1 get 0 get ne
   {
      % First two x coordintates not equal. Start on second number to get verticals.
      /p:start 1 def
   } if

   /p:end p:start p:len add 1 sub def

   p:start 2 p:end
   {
      dup
      p:data exch get /p:a exch def 
      p:data exch 1 add p:len mod get /p:b exch def

      p:a 0 get         % Get x
      p:a 1 get         % Get y1
      p:b 1 get         % Fet y2
      2 copy min        % Find min of y1 and y2
      3 1 roll max      % Find max of y1 and y2
      3 array astore    % Make array [x y1 y2]

      p:verticals exch append /p:verticals exch def
   } for
} bind def


/p:find_x_min_max
{
   p:horizontals
   {
      aload pop
      /p:x_max exch p:x_max max def
      /p:x_min exch p:x_min min def
      pop
   } forall
} bind def

/p:find_y_min_max
{
   p:verticals
   {
      aload pop
      /p:y_max exch p:y_max max def
      /p:y_min exch p:y_min min def
      pop
   } forall
} bind def


/p:find_horizontal_ranges
{
   p:find_y_min_max

   p:y_min 1 p:y_max
   {
      /p:y exch def
      /p:crossings [] def
      /p:intervals [] def

      % Get array of all vericals crossing a horizontal line at p:y.
      p:verticals
      {
         aload pop      % -- x y1 y2
         p:y gt exch    % p:y < y2
         p:y le and     % y1 <= p:y
         {
            /p:crossings p:crossings 3 -1 roll append def   % append x to p:crossings
         }
         { pop } ifelse
      } forall

      p:crossings sort_array

      % Pair the crossings to ranges
      0 2 p:crossings length 2 sub
      {
         p:crossings exch 2 getinterval
         /p:intervals p:intervals 3 -1 roll append def
      } for

      p:y_to_xranges p:y p:intervals put
   } for
} bind def

/p:find_vertical_ranges
{
   p:find_x_min_max

   p:x_min 1 p:x_max
   {
      /p:x exch def
      /p:crossings [] def
      /p:intervals [] def

      % Get array of all horizontals crossing a vertical line at p:x.
      p:horizontals
      {
         aload pop      % -- y x1 x2
         p:x gt exch    % p:x < x2
         p:x le and     % x1 <= p:x
         {
            /p:crossings p:crossings 3 -1 roll append def   % append x to p:crossings
         }
         { pop } ifelse
      } forall

      p:crossings sort_array

      % Pair the crossings to ranges
      0 2 p:crossings length 2 sub
      {
         p:crossings exch 2 getinterval
         /p:intervals p:intervals 3 -1 roll append def
      } for

      p:x_to_yranges p:x p:intervals put
   } for
} bind def

/p:test_range_in_ranges  % [a b]  [[q w] [r s] ...] -- bool
{
   /p:found false def

   {
      aload pop            % [a b] q w
      2 index aload pop    % [a b] q w a b
      3 -1 roll            % [a b] q a b w
      le 3 1 roll          % [a b] bool q a
      le and               % [a b] bool
      { /p:found true def exit } if
   } forall

   pop
   p:found
} bind def

/p:test_rectangle  % [x y] [x y] --
{
   /p:a exch def
   /p:b exch def

   /p:x0 p:a 0 get p:b 0 get min def
   /p:x1 p:a 0 get p:b 0 get max def
   /p:y0 p:a 1 get p:b 1 get min def
   /p:y1 p:a 1 get p:b 1 get max def
   /p:ok true def

   [p:x0 p:x1] p:y_to_xranges p:y0 get p:test_range_in_ranges
   [p:x0 p:x1] p:y_to_xranges p:y1 get p:test_range_in_ranges and

   [p:y0 p:y1] p:x_to_yranges p:x0 get p:test_range_in_ranges
   [p:y0 p:y1] p:x_to_yranges p:x1 get p:test_range_in_ranges and and

   {
      p:x1 p:x0 sub 1 add p:y1 p:y0 sub 1 add mul
   }
   {
      0
   } ifelse
} bind def

/p:test_rectangles
{
   /input exch def
   /len input length def
   /current_max 0 def

   0 1 len 2 sub
   {
      /i exch def

      i 1 add 1 len 1 sub
      {
         /j exch def

         input i get
         input j get
         p:test_rectangle

         /current_max exch current_max max def
      } for
   } for
   current_max
} bind def

%% ------------------------------

/largest_square
{
   /input exch def
   /len input length def
   /current_max 0 def

   0 1 len 2 sub
   {
      /i exch def

      i 1 add 1 len 1 sub
      {
         /j exch def

         /a input i get def
         /b input j get def

         a 0 get b 0 get sub abs 1 add 
         a 1 get b 1 get sub abs 1 add mul
         /current_max exch current_max max def
      } for
   } for
   current_max
} bind def


%% ------------------------------

setup_output

input_data largest_square /result_step_1 exch def

p:init
input_data p:find_horizontals
input_data p:find_verticals

p:find_horizontal_ranges
p:find_vertical_ranges

input_data p:test_rectangles /result_step_2 exch def


% Output to paper
LM TM moveto
setbold (Advent of Code 2025) prtstr setnormal newline newline
(- Day 9 -) prtstr 1 1 6 { pop newline } for
setbold (Result step 1: ) prtstr setnormal result_step_1 100 string cvs prtstr newline newline
setbold (Result step 2: ) prtstr setnormal result_step_2 100 string cvs prtstr newline

% Write to stdout as well
(\nAdvent of Code 2025  - Day 9 - Anders Piniesjö\n) println 
(Result step 1: ) print result_step_1 20 string cvs println
(Result step 2: ) print result_step_2 20 string cvs println
