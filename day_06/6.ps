%!PS-Adobe-3.0
%%BoundingBox: 24 24 571 818
%%Title: Advent of Code 2025 - day 6
%%For: Hackvalue
%%Creator: Anders Piniesjö
%%CreationDate: Mon Dec 13 01:18:41 2025
%%Orientation: Portrait
%%DocumentMedia: A4 595 842 0 () ()
%%EndComments

% -----------------------------------------------------------------------
%  Advent of Code 2025 in Postscript - Day 6
%  by Anders Piniesjö
%
%  Run with: ghostscript 6.ps
%  
%  -- Or print it on a Postscript printer!
% -----------------------------------------------------------------------

%% ----- Data -------

/problem_numbers [
% <<INJECT DATA HERE>>
] bind def

%% ----- Output -------

/setup_output
{
   /stdout (%stdout) (w) file def
   /print { stdout exch writestring } bind def
   /println { print stdout (\n) writestring } bind def

   /LM   50 def      % Left margin
   /RM   578 def     % Right margin
   /TM   700 def     % Top margin
   /BM   10 def      % Bottom margin
   /fontsize 18 def  % Change this to change font-size
   /ypos TM def      % current y-position
   /lineheight fontsize def

   /font_normal /Times-Roman findfont fontsize scalefont def
   /font_bold /Times-Bold findfont fontsize scalefont def
   font_normal setfont
} def

/newline
 { currentpoint exch pop lineheight sub  % calc y-val
   BM lt                                 % check if less than bottom margin
   { showpage LM TM moveto               % New page
     /ypos TM def }
   { ypos lineheight sub                 % Go left/down
     /ypos exch def
     LM ypos moveto } ifelse
} def
   
/prtstr
 { dup stringwidth pop      % calc length of string
   currentpoint pop         % get horizontal position
   add RM gt                % sum > right margin?
   {newline} if             % if so, next line
   show 
} def

/setnormal { font_normal setfont } bind def
/setbold { font_bold setfont } bind def

%% ---- Utils ------

/max  %% int int -- int   | Return max of two ints
{
   2 copy lt { exch pop } { pop } ifelse
} bind def

/append   %% array elem -- array with elem   | Append elem to array, returning a new array with result.
{
   1 index length dup 1 add array   % Create new larger array.
   dup 0 6 -1 roll putinterval      % Copy old array into new.
   dup 4 -2 roll                    % Duplicate array and stack roll.
   exch put                         % Put element to end.
} bind def


%% ----- Input conversion -------

/split_string  %% str -- array   | Split a string with items separated by space into an array of correct types
{
   /s exch def
   s length array /out exch def
   /n 0 def

   {
      s token  % Tokenize one, stack: rest token bool
      {
         exch /s exch def     % Store rest.
         out n 3 -1 roll put
         /n n 1 add def
      }
      { exit } ifelse
   } loop

   n array dup 0 out 0 n getinterval putinterval   % Trim array.
} def

/split_input  %% input array -- output array   | Split all input to array with arrays of tokens.
{
   /input exch def
   /rowslen input length def
   /parsed rowslen array def

   0 1 rowslen 1 sub
   {
      /r exch def
      input r get
      split_string
      parsed r 3 -1 roll put
   } for

   parsed
} bind def


/add_n   % n -- sum   | Sum n number of integers from stack
{
   0 exch { add } repeat
} def

/mul_n   % n -- sum   | Multiply n number of integers from stack 
{
   1 exch { mul } repeat
} def


/calc_op  % any1 .. anyn op n -- int
{
   1 sub    % -1 to not count op char

   exch /* eq
   {
      mul_n
   }
   {
      add_n
   } ifelse

} bind def


/read_puzzle  %% array -- 
{
   /input exch def
   /read_puzzle_sum 0 def

   input split_input /split exch def
   split length /height exch def
   split 0 get length /width exch def

   0 1 width 1 sub 
   {
      /x exch def
      0 1 height 1 sub
      {
         /y exch def

         split y get x get         
         
      } for
      height calc_op
      /read_puzzle_sum exch read_puzzle_sum add def
   } for
   read_puzzle_sum
} bind def


/push_number_token  %% int int - int   | push a new number, pushing existing up (*10)
{
   token { exch pop exch 10 mul add } if
} bind def


/vertical_iter
{
   /input exch def   

   input length /height exch def
   input 0 get length /width exch def
   /op_row height 1 sub def

   /vertical_puzzle_sum 0 def
   /workarray [] def
   /current_number 0 def

   width 1 sub -1 0  %% iter from right to left
   {
      /x exch def
      0 1 height 1 sub  %% iter from top to bottom
      {
         /y exch def

         y op_row lt
         {
            % Build numbers by pushing to right side.
            input y get x get
            1 string dup 0 4 -1 roll put
            current_number exch push_number_token /current_number exch def
         }
         {
            current_number 0 ne
            {
               workarray current_number append /workarray exch def   % Add finished number to work array.
            } if

            /current_number 0 def

            input y get x get
            dup
            32 ne    % 32 = " "
            {
               43 eq  
               {  % +
                  workarray aload pop
                  workarray length
                  add_n
                  /vertical_puzzle_sum exch vertical_puzzle_sum add def
               }
               {  % *
                  workarray aload pop
                  workarray length
                  mul_n
                  /vertical_puzzle_sum exch vertical_puzzle_sum add def
               } ifelse

               /workarray [] def
            }
            {
               pop
            } ifelse
         } ifelse
      } for
   } for
   vertical_puzzle_sum
} bind def


%% ------------------------------

setup_output

problem_numbers read_puzzle /step_1_answer exch def
problem_numbers vertical_iter /step_2_answer exch def

% Output to paper
LM TM moveto
setbold (Advent of Code 2025) prtstr setnormal newline newline
(- Day 6 -) prtstr 1 1 6 { pop newline } for
setbold (Sum step 1: ) prtstr setnormal step_1_answer 100 string cvs prtstr newline newline
setbold (Sum step 2: ) prtstr setnormal step_2_answer 100 string cvs prtstr newline

% Write to stdout as well
(\nAdvent of Code 2025  - Day 6 - Anders Piniesjö\n) println 
(Sum step 1: ) print step_1_answer 20 string cvs println
(Sum step 2: ) print step_2_answer 20 string cvs println
