%!PS-Adobe-3.0
%%BoundingBox: 24 24 571 818
%%Title: Advent of Code 2025 - day 10
%%For: Hackvalue
%%Creator: Anders Piniesjö
%%CreationDate: Mon Dec 13 22:47:41 2025
%%Orientation: Portrait
%%DocumentMedia: A4 595 842 0 () ()
%%EndComments

% -----------------------------------------------------------------------
%  Advent of Code 2025 in Postscript - Day 10
%  by Anders Piniesjö
%
%  Run with: ghostscript 10.ps
%  
%  -- Or print it on a Postscript printer!
% -----------------------------------------------------------------------

%% ----- Data -------

/test_data [
[(.##.) [[3] [1 3] [2] [2 3] [0 2] [0 1]] [3 5 4 7]]
[(...#.) [[0 2 3 4] [2 3] [0 4] [0 1 2] [1 2 3 4]] [7 5 12 7 2]]
[(.###.#) [[0 1 2 3 4] [0 3 4] [0 1 2 4 5] [1 2]] [10 11 11 5 10 5]]
] bind def

/input_data [
% <<INJECT DATA HERE>>
] bind def

%% ----- Output -------

/setup_output
{
   /stdout (%stdout) (w) file def
   /print { stdout exch writestring } bind def
   /println { print stdout (\n) writestring } bind def

   /LM   50 def      % Left margin
   /RM   578 def     % Right margin
   /TM   700 def     % Top margin
   /BM   10 def      % Bottom margin
   /fontsize 18 def  % Change this to change font-size
   /ypos TM def      % current y-position
   /lineheight fontsize def

   /font_normal /Times-Roman findfont fontsize scalefont def
   /font_bold /Times-Bold findfont fontsize scalefont def
   font_normal setfont
} def

/newline
 { currentpoint exch pop lineheight sub  % calc y-val
   BM lt                                 % check if less than bottom margin
   { showpage LM TM moveto               % New page
     /ypos TM def }
   { ypos lineheight sub                 % Go left/down
     /ypos exch def
     LM ypos moveto } ifelse
} def
   
/prtstr
 { dup stringwidth pop      % calc length of string
   currentpoint pop         % get horizontal position
   add RM gt                % sum > right margin?
   {newline} if             % if so, next line
   show 
} def

/setnormal { font_normal setfont } bind def
/setbold { font_bold setfont } bind def

%% ---- Utils ------

/min  %% int int -- int   | Return min of two ints
{
   2 copy gt { exch pop } { pop } ifelse
} bind def

/max  %% int int -- int   | Return max of two ints
{
   2 copy lt { exch pop } { pop } ifelse
} bind def

/append   %% array elem -- array with elem   | Append elem to array, returning a new array with result.
{
   1 index length dup 1 add array   % Create new larger array.
   dup 0 6 -1 roll putinterval      % Copy old array into new.
   dup 4 -2 roll                    % Duplicate array and stack roll.
   exch put                         % Put element to end.
} bind def


/lamps_to_int
{
   /p:lamps exch def
   /p:lampresult 0 def

   0 1 p:lamps length 1 sub
   {
      /p:i exch def
      p:lamps p:i get 35 eq   % '#' = 35
      {
         /p:lampresult p:lampresult 1 p:i bitshift or def
      } if
   } for

   p:lampresult
} bind def


/buttons_to_int_array
{
   /bia:lampcount exch def
   /bia:buttons exch def
   /bia:result [] def

   bia:buttons
   {
      /bia:button_value 0 def
      {
         1 exch bitshift
         /bia:button_value exch bia:button_value or def
      } forall
      /bia:result bia:result bia:button_value append def
   } forall

   bia:result
} bind def


/array_all_zero  % array -- bool  | Return true if all elements in array is 0.
{
  true exch
  {
    0 ne { pop false exit } if
  } forall
} bind def



%% --- Step 1 ----------
%% The solution idea is that the target lamp configuration as well as the button
%% presses can be seen as binary numbers. That reduces the problem to XOR of 
%% integers. Next idea is that no button can be pressed more than once for a
%% lowest result. Multiple presses of a button would just toggle the effect,
%% due to the XOR operation.

/s1:solve_problem
{
   aload pop 
   /sp:jolts exch def
   /sp:buttons exch def
   pop   % Skip buttons array
   /sp:lamps exch def
   /sp:buttons_count sp:buttons length def 
   /sp:result 10000 def

   % Loop 0 .. 2^buttons_count - 1
   0 1 1 sp:buttons_count bitshift 1 sub
   {  
      /sp:mask exch def
      /sp:val 0 def
      /sp:presscount 0 def

      0 1 sp:buttons_count 1 sub
      {
         /i exch def
         sp:mask 1 i bitshift and 0 ne
         {
            /sp:val sp:val sp:buttons i get xor def
            /sp:presscount sp:presscount 1 add def
         } if
      } for

      sp:val sp:lamps eq
      {
         /sp:result sp:result sp:presscount min def
      } if   
   } for

   sp:result 10000 eq { /sp:result 0 def } if
   sp:result
} bind def


/s1:solve_problems
{
   /s:result 0 def
   {
      s1:solve_problem
      /s:result exch s:result add def
   } forall

   s:result
} bind def


/s1:parse_indata
{
   /p:input exch def
   /p:result [] def

   p:input
   {
      aload pop
      /p:jolts exch def
      /p:buttons exch def
      /p:target exch def

      p:target lamps_to_int /p:target_int exch def
      p:buttons p:target length buttons_to_int_array /p:buttons_int_array exch def

      [p:target_int p:buttons p:buttons_int_array p:jolts]

      /p:result p:result 3 -1 roll append def
   } forall

   p:result
} bind def



%% --- Step 2 ----------

/p2:solve_lamp_config
{
   /p2:lamp_config exch def   % Lamp config to find
   /p2:config_results [] def

   % % Loop 0 .. 2^p2:buttons_len - 1 (All button combinations)
   0 1 1 p2:buttons_len bitshift 1 sub
   {  
      /p2:mask exch def       % button mask this turn
      /p2:val 0 def
      /p2:presscount 0 def
      /p2:presslist [] def

      /p2:joltsdelta p2:jolts_len array def
      0 1 p2:jolts_len 1 sub { p2:joltsdelta exch 0 put } for

      0 1 p2:buttons_len 1 sub
      {
         /i exch def
         p2:mask 1 i bitshift and 0 ne
         {
            /p2:presscount p2:presscount 1 add def
            /p2:val p2:val p2:buttons i get xor def

            p2:buttons_array i get
            {
               dup
               p2:joltsdelta exch p2:joltsdelta 4 -1 roll get 1 add put
            } forall
            /p2:presslist p2:presslist i append def
         } if
      } for

      p2:val p2:lamp_config eq
      {
         /p2:config_results p2:config_results [p2:presscount p2:joltsdelta] append def
      } if

   } for

   p2:lamps_dict p2:lamp_config p2:config_results put
} bind def

/p2:lsb_bit_slice_old
{
   /p2:input_jolts exch def
   /p2:lsb_bit_slice_result 0 def

   0 1 p2:input_jolts length 1 sub
   {
      /j exch def
      /p2:lsb_bit_slice_result p2:lsb_bit_slice_result 1 bitshift def
      p2:input_jolts j get 1 and
      /p2:lsb_bit_slice_result exch p2:lsb_bit_slice_result or def
   } for

   p2:lsb_bit_slice_result
} bind def


/p2:lsb_bit_slice
{
   /p2:input_jolts exch def
   /p2:res 0 def

   0 1 p2:input_jolts length 1 sub
   {
      /j exch def
      p2:input_jolts j get 1 and 1 eq
      {
         /p2:res p2:res 1 j bitshift or def
      } if
   } for

   p2:res
} bind def


/p2:transform_joltages
{
   /p2:input_delta exch def
   /p2:input_jolts exch def
   /p2:transform_result p2:input_jolts length array def

   0 1 p2:input_jolts length 1 sub
   {
      /t exch def
      p2:input_jolts t get
      p2:input_delta t get sub
      2 idiv
      p2:transform_result t 3 -1 roll put
   } for
   p2:transform_result
} bind def 

/p2:iterate_jolt_bits
{
   /p2:max_jolt 0 def
   p2:jolts { /p2:max_jolt exch p2:max_jolt max def } forall    % Get highest jolt number
   /p2:jolt_bit_len p2:max_jolt ln 2 ln div floor cvi 1 add def  % Calculate number of bits in highest jolt number
   /p2:slice_array p2:jolt_bit_len array def
   /p2:states [[0 p2:jolts]] def
   /p2:scale 1 def

   {
      p2:scale p2:max_jolt ge { exit } if
      /p2:new_states [] def

      p2:states
      {
         aload pop
         /p2:state_joltages exch def
         /p2:loop_presses exch def

         p2:state_joltages p2:lsb_bit_slice   % Get LSB:s for jolts.
         p2:lamps_dict exch get

         {  % For all press variant in lamp setting
            aload pop
            /p2:combo_delta exch def
            /p2:combo_presses exch def
            /p2:new_jolts p2:state_joltages p2:combo_delta p2:transform_joltages def

            /ok true def
            p2:new_jolts {
               0 lt { /ok false def } if
            } forall

            ok {
               /p2:new_states p2:new_states
                  [p2:loop_presses p2:combo_presses p2:scale mul add
                   p2:new_jolts] append def
            } if
         } forall

      } forall

      /p2:states p2:new_states def
      /p2:scale p2:scale 2 mul def
   } loop

   /p2:lowest 100000 def
   p2:states
   {
      0 get p2:lowest min /p2:lowest exch def
   } forall

   p2:lowest
} bind def


/p2:solve_problem
{
   aload pop
   /p2:jolts exch def                     % array of jolt numbers
   /p2:jolts_len p2:jolts length def      % int, number of jolt numbers
   /p2:buttons exch def                   % array of button ints
   /p2:buttons_array exch def             % array of button lamps
   /p2:lamps exch def                     % int representation of lamps
   /p2:buttons_len p2:buttons length def  % number of buttons
   /p2:lamps_dict 100000 dict def

   % Try to find solutions for 0 .. 2^p2:jolts_len - 1 combinations. Stor in dict.
   0 1 1 p2:jolts_len bitshift 1 sub
   {
      p2:solve_lamp_config
   } for

   p2:iterate_jolt_bits

   (Machine result: ) print dup 20 string cvs println
   % (----------------------------------) =
} bind def


/p2:solve_problems
{
   /p2:result 0 def
   {
      p2:solve_problem
      /p2:result exch p2:result add def
   } forall

   p2:result
} bind def

%% ------------------------------


setup_output

%test_data s1:parse_indata /s1:parsed_data exch def
input_data s1:parse_indata /s1:parsed_data exch def

s1:parsed_data s1:solve_problems /result_step_1 exch def
s1:parsed_data p2:solve_problems /result_step_2 exch def

% Output to paper
LM TM moveto
setbold (Advent of Code 2025) prtstr setnormal newline newline
(- Day 10 -) prtstr 1 1 6 { pop newline } for
setbold (Result step 1: ) prtstr setnormal result_step_1 100 string cvs prtstr newline newline
setbold (Result step 2: ) prtstr setnormal result_step_2 100 string cvs prtstr newline

% Write to stdout as well
(\nAdvent of Code 2025  - Day 10 - Anders Piniesjö\n) println 
(Result step 1: ) print result_step_1 20 string cvs println
(Result step 2: ) print result_step_2 20 string cvs println
