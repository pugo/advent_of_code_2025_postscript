%!PS-Adobe-3.0
%%BoundingBox: 24 24 571 818
%%Title: Advent of Code 2025 - day 5
%%For: Hackvalue
%%Creator: Anders Piniesjö
%%CreationDate: Mon Dec 11 22:29:41 2025
%%Orientation: Portrait
%%DocumentMedia: A4 595 842 0 () ()
%%EndComments

% -----------------------------------------------------------------------
%  Advent of Code 2025 in Postscript - Day 5
%  by Anders Piniesjö
%
%  Run with: ghostscript 5.ps
%  
%  -- Or print it on a Postscript printer!
% -----------------------------------------------------------------------

%% ----- Data -------

/fresh_ranges [
% <<INJECT RANGES DATA HERE>>
] bind def

/ingredients [
% <<INJECT INGREDIENTS DATA HERE>>
] def


%% ----- Output -------

/setup_output
{
   /stdout (%stdout) (w) file def
   /print { stdout exch writestring } bind def
   /println { print stdout (\n) writestring } bind def

   /LM   50 def      % Left margin
   /RM   578 def     % Right margin
   /TM   700 def     % Top margin
   /BM   10 def      % Bottom margin
   /fontsize 18 def  % Change this to change font-size
   /ypos TM def      % current y-position
   /lineheight fontsize def

   /font_normal /Times-Roman findfont fontsize scalefont def
   /font_bold /Times-Bold findfont fontsize scalefont def
   font_normal setfont
} def

/newline
 { currentpoint exch pop lineheight sub  % calc y-val
   BM lt                                 % check if less than bottom margin
   { showpage LM TM moveto               % New page
     /ypos TM def }
   { ypos lineheight sub                 % Go left/down
     /ypos exch def
     LM ypos moveto } ifelse
} def
   
/prtstr
 { dup stringwidth pop      % calc length of string
   currentpoint pop         % get horizontal position
   add RM gt                % sum > right margin?
   {newline} if             % if so, next line
   show 
} def

/setnormal { font_normal setfont } bind def
/setbold { font_bold setfont } bind def

%% ---- Utils ------

/max  %% int int -- int   | Return max of two ints
{
   2 copy lt { exch pop } { pop } ifelse
} bind def

%% ----- Input conversion -------

/make_ranges_array  % data -- array   | Make array with ranges [A B] from array of strings (A-B)
{
   /input exch def
   input length /len exch def
   /result len array def

   0 1 len 1 sub
   {
      dup input exch get (-) search
      {
         exch pop           % Skip (-)
         cvi exch cvi       % Both to int  
         2 array astore     % Array with range [start stop]
      } if

      result 3 1 roll put
   } for

   result
} bind def

/count_fresh  %% Array Array -- int  | Find number of fresh ingredients
{
   /ingr exch def
   /ranges exch def
   /fresh_sum 0 def

   ingr
   {
      /i exch def

      ranges
      { % Loop over range array.
         aload pop   % push array on stack and pop array
         i exch le exch
         i exch ge and
         {
            /fresh_sum fresh_sum 1 add def
            exit
         } if
      } forall
   } forall

   fresh_sum
} bind def

/sort_range_sweep
{
   /swapcount 0 def
   dup length 2 sub
   0 1 3 -1 roll
   {
      /i exch def
      dup /a exch i get def
      dup /b exch i 1 add get def

      a 0 get b 0 get gt
      {
         dup i b put
         dup i 1 add a put
         /swapcount swapcount 1 add def
      } if
   } for
   pop  % pop array
   swapcount
} def

/sort_ranges  %% Array --  | Sorts the array with ranges after start
{
   /target exch def
   % Simple bubble sort is enough.
   {
      target sort_range_sweep
      0 eq { exit } if
   } loop
} bind def

/merge_ranges  %% Array -- Array  | Merge ranges that have overlapping ends/starts
{
   /sorted_array exch def
   /len sorted_array length def

   /new_array len array def
   /new_pos 0 def

   /current sorted_array 0 get def

   1 1 len 1 sub
   {
      /next sorted_array 3 -1 roll get def

      next 0 get current 1 get 1 add le   % +1 to current end to merge adjacent.
      {
         current 1 next 1 get current 1 get max put
      }
      {
         new_array new_pos current put
         /new_pos new_pos 1 add def
         /current next def
      } ifelse
   } for

   new_array new_pos current put
   /new_pos new_pos 1 add def

   new_pos array                          % Make array with correct number of items.
   dup 0 new_array 0 new_pos getinterval  % result result 0 (slice).
   putinterval                            % Copy old array to new.
} bind def

/count_elements_in_ranges  %% Array - int  | Iterate the array and sum elements of all ranges
{
   /result 0 def
   {
      dup 0 get
      exch 1 get
      exch sub 1 add
      /result result 3 -1 roll add def
   } forall

   result
} bind def


%% ------------------------------

setup_output

% Parse input ranges to an array of [start stop] arrays.
fresh_ranges make_ranges_array /fresh_ranges_array exch def

% Sort and merge the ranges
fresh_ranges_array sort_ranges 
fresh_ranges_array merge_ranges /merged_ranges_array exch def

% Find ingredients and count the ranges.
merged_ranges_array ingredients count_fresh /number_of_fresh_ingredients exch def
merged_ranges_array count_elements_in_ranges /number_of_fresh_ids exch def

% Output to paper
LM TM moveto
setbold (Advent of Code 2025) prtstr setnormal newline newline
(- Day 5 -) prtstr 1 1 6 { pop newline } for
setbold (Fresh ingredients (step 1):  ) prtstr setnormal number_of_fresh_ingredients 100 string cvs prtstr newline newline
setbold (    Number of IDs (step 2):  ) prtstr setnormal number_of_fresh_ids 100 string cvs prtstr newline

% Write to stdout as well
(\nAdvent of Code 2025  - Day 5 - Anders Piniesjö\n) println 
(Fresh ingredients (step 1): ) print number_of_fresh_ingredients 20 string cvs println
(    Number of IDs (step 2): ) print number_of_fresh_ids 20 string cvs println
