%!PS-Adobe-3.0
%%BoundingBox: 24 24 571 818
%%Title: Advent of Code 2025 - day 8
%%For: Hackvalue
%%Creator: Anders Piniesjö
%%CreationDate: Mon Dec 13 22:47:41 2025
%%Orientation: Portrait
%%DocumentMedia: A4 595 842 0 () ()
%%EndComments

% -----------------------------------------------------------------------
%  Advent of Code 2025 in Postscript - Day 8
%  by Anders Piniesjö
%
%  Run with: ghostscript 8.ps
%  
%  -- Or print it on a Postscript printer!
% -----------------------------------------------------------------------

%% ----- Data -------

/test_data [
[162 817 812]
[57 618 57]
[906 360 560]
[592 479 940]
[352 342 300]
[466 668 158]
[542 29 236]
[431 825 988]
[739 650 466]
[52 470 668]
[216 146 977]
[819 987 18]
[117 168 530]
[805 96 715]
[346 949 466]
[970 615 88]
[941 993 340]
[862 61 35]
[984 92 344]
[425 690 689]
] bind def
 
/input_data [
% <<INJECT DATA HERE>>
] bind def

%% ----- Output -------

/setup_output
{
   /stdout (%stdout) (w) file def
   /print { stdout exch writestring } bind def
   /println { print stdout (\n) writestring } bind def

   /LM   50 def      % Left margin
   /RM   578 def     % Right margin
   /TM   700 def     % Top margin
   /BM   10 def      % Bottom margin
   /fontsize 18 def  % Change this to change font-size
   /ypos TM def      % current y-position
   /lineheight fontsize def

   /font_normal /Times-Roman findfont fontsize scalefont def
   /font_bold /Times-Bold findfont fontsize scalefont def
   font_normal setfont
} def

/newline
 { currentpoint exch pop lineheight sub  % calc y-val
   BM lt                                 % check if less than bottom margin
   { showpage LM TM moveto               % New page
     /ypos TM def }
   { ypos lineheight sub                 % Go left/down
     /ypos exch def
     LM ypos moveto } ifelse
} def
   
/prtstr
 { dup stringwidth pop      % calc length of string
   currentpoint pop         % get horizontal position
   add RM gt                % sum > right margin?
   {newline} if             % if so, next line
   show 
} def

/setnormal { font_normal setfont } bind def
/setbold { font_bold setfont } bind def

%% ---- Utils ------

/max  %% int int -- int   | Return max of two ints
{
   2 copy lt { exch pop } { pop } ifelse
} bind def

/append   %% array elem -- array with elem   | Append elem to array, returning a new array with result.
{
   1 index length dup 1 add array   % Create new larger array.
   dup 0 6 -1 roll putinterval      % Copy old array into new.
   dup 4 -2 roll                    % Duplicate array and stack roll.
   exch put                         % Put element to end.
} bind def

/deep_copy_stringarray  %% array -- array   | Deep copy an array of strings.
{
   /old exch def
   /new old length array def

   0 1 old length 1 sub
   {                       % i
      dup old exch get     % i str
      dup length string    % i str newstr
      0 3 -1 roll          % i newstr 0 str
      dup length 0 exch    % i newstr 0 str 0 slen
      getinterval          % i newstr 0 str
      2 index              % i newstr 0 str newstr
      5 1 roll             % newstr i newstr 0 str
      putinterval          % newstr i
      new exch 3 -1 roll   % new i 
      put    
   } for
   new
} bind def

/sort_array_sweep
{
   /s:swapcount 0 def
   dup length 2 sub
   0 1 3 -1 roll
   {
      /s:i exch def
      dup /s:a exch s:i get def
      dup /s:b exch s:i 1 add get def

      s:a null eq { /s:a 0 def } if
      s:b null eq { /s:b 0 def } if

      s:a s:b gt
      {
         dup s:i s:b put
         dup s:i 1 add s:a put
         /s:swapcount s:swapcount 1 add def
      } if
   } for
   pop  % pop array
   s:swapcount
} def

/sort_array  %% Array --  | Sorts the array with numbers
{
   /target exch def
   {
      target sort_array_sweep
      0 eq { exit } if
   } loop
} bind def

%% --- distance list ----------

/dl:init
{
   /dl:list 1010 array def
   /dl:max dl:list length 1 sub def
   /dl:index 0 def
} bind def

/dl:put %% any --     | Put item to distlist
{
   % Put new element at end.
   dl:list dl:index 3 -1 roll put   

   % Move into sorted position.
   dl:index 0 gt
   {
      dl:index -1 1
      {
         /dl:i exch def
         /a dl:list dl:i 1 sub get def
         /b dl:list dl:i get def

         a 0 get b 0 get gt
         {
            dl:list dl:i 1 sub b put
            dl:list dl:i a put
         }
         {
            exit
         } ifelse
      } for
   } if

   dl:index dl:max lt
   { 
      /dl:index dl:index 1 add def  % Increase index if not reached max.
   } if
} bind def

%% --- circuit dict ----------

/c:init
{
   /c:dict 2000 dict def
   /c:next_group_nr 1 def
} bind def

/c:put  %% connection-array --    | Add a connection to circuit dict
{
   /c:ca exch def
   /c:a c:ca 1 get def
   /c:b c:ca 2 get def

   /c:aknown c:dict c:a known def
   /c:bknown c:dict c:b known def

   c:aknown c:bknown or
   {
      c:aknown c:bknown and
      {
         % Both are in circuit, check if it is same.
         c:dict c:a get
         c:dict c:b get eq
         {
            % They are both in same circuit already. Do nothing more.
         }
         {
            % They are in different circuits. Merge them.
            /c:change_from c:dict c:b get def
            /c:change_to c:dict c:a get def
            c:dict
            {
               c:change_from eq
               {
                  c:dict exch c:change_to put
               }
               {
                  pop
               } ifelse
            } forall

         } ifelse
      }
      {
         % One is in circuit, add the other to the same one.
         c:aknown
         {
            % Add B to same circuit as A.
            c:dict c:a get
            c:dict c:b 3 -1 roll put
         }
         {
            % Add A to same circuit as B.
            c:dict c:b get
            c:dict c:a 3 -1 roll put
         } ifelse
      } ifelse
   } 
   {
      % None of them are in circuit, add both to new one.
      c:new_group_nr dup
      c:dict c:a 3 -1 roll put
      c:dict c:b 3 -1 roll put
   } ifelse

} bind def

/c:new_group_nr
{
   /c:result c:next_group_nr def
   /c:next_group_nr c:next_group_nr 1 add def
   c:result
} bind def

/c:sum_largest_circuit_sizes  %% n - int  | Sum the n largest circuit sizes and return sum.
{
   /c:n exch def

   /c:largest_nr 0 def
   c:dict { /c:largest_nr exch c:largest_nr max def pop } forall  % Get largest group number.

   /c:sum_array c:largest_nr 1 add array  def

   c:dict 
   {
      exch pop
      dup c:sum_array exch get null eq
      { c:sum_array exch 1 put }
      { dup c:sum_array exch get 1 add c:sum_array 3 -2 roll put } 
      ifelse
   } forall

   c:sum_array sort_array
   c:sum_array ==

   /c:sum 1 def
   /c:last c:sum_array length 1 sub def
   c:last -1 c:last c:n sub 1 add
   {
      c:sum_array exch get
      /c:sum exch c:sum mul def
   } for

   c:sum
} bind def


%% ------------------------------

/meassure_pairs  % array
{
   /input exch def
   /len input length def
   dl:init

   0 1 len 2 sub
   {
      /i exch def

      i 1 add 1 len 1 sub
      {
         /j exch def
         /a input i get def
         /b input j get def
         /d 
         a 0 get b 0 get sub dup mul
         a 1 get b 1 get sub dup mul add
         a 2 get b 2 get sub dup mul add def

         % i 10 string cvs print (, ) print j 10 string cvs print (, ) print d 20 string cvs println
         [d i j a b] dl:put
      } for
   } for

   % dl:list ==
} bind def

/connect    %% n --    | Connect n shortest pairs.
{
   /cn exch def
   c:init

   0 1 cn 1 sub
   {
      dl:list exch get c:put
   } for
} bind def


%% ------------------------------

setup_output

input_data meassure_pairs
%test_data meassure_pairs

% dl:list
% {
%    ==
% } forall
% () println

1000 connect
3 c:sum_largest_circuit_sizes /result_step_1 exch def

% c:dict
% {
%    exch 
%    (index: ) print 10 string cvs print (, group: ) print 10 string cvs println
% } forall

% Output to paper
LM TM moveto
setbold (Advent of Code 2025) prtstr setnormal newline newline
(- Day 8 -) prtstr 1 1 6 { pop newline } for
setbold (Result step 1: ) prtstr setnormal result_step_1 100 string cvs prtstr newline newline
%setbold (Sum step 2: ) prtstr setnormal step_2_answer 100 string cvs prtstr newline

% Write to stdout as well
(\nAdvent of Code 2025  - Day 8 - Anders Piniesjö\n) println 
(Result step 1: ) print result_step_1 20 string cvs println
%(Sum step 2: ) print step_2_answer 20 string cvs println
