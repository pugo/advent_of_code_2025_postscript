%!PS-Adobe-3.0
%%BoundingBox: 24 24 571 818
%%Title: Advent of Code 2025 - day 11
%%For: Hackvalue
%%Creator: Anders Piniesjö
%%CreationDate: Mon Dec 13 22:47:41 2025
%%Orientation: Portrait
%%DocumentMedia: A4 595 842 0 () ()
%%EndComments

% -----------------------------------------------------------------------
%  Advent of Code 2025 in Postscript - Day 11
%  by Anders Piniesjö
%
%  Run with: ghostscript 11.ps
%  
%  -- Or print it on a Postscript printer!
% -----------------------------------------------------------------------

%% ----- Data -------

/test_data <<
(aaa) [(you) (hhh)]
(you) [(bbb) (ccc)]
(bbb) [(ddd) (eee)]
(ccc) [(ddd) (eee) (fff)]
(ddd) [(ggg)]
(eee) [(out)]
(fff) [(out)]
(ggg) [(out)]
(hhh) [(ccc) (fff) (iii)]
(iii) [(out)]
>> def

/test_data_step_2 <<
(svr) [(aaa) (bbb)]
(aaa) [(fft)]
(fft) [(ccc)]
(bbb) [(tty)]
(tty) [(ccc)]
(ccc) [(ddd) (eee)]
(ddd) [(hub)]
(hub) [(fff)]
(eee) [(dac)]
(dac) [(fff)]
(fff) [(ggg) (hhh)]
(ggg) [(out)]
(hhh) [(out)]
>> def

/input_data <<
% <<INJECT DATA HERE>>
>> def

%% ----- Output -------

/setup_output
{
   /stdout (%stdout) (w) file def
   /print { stdout exch writestring } bind def
   /println { print stdout (\n) writestring } bind def

   /LM   50 def      % Left margin
   /RM   578 def     % Right margin
   /TM   700 def     % Top margin
   /BM   10 def      % Bottom margin
   /fontsize 18 def  % Change this to change font-size
   /ypos TM def      % current y-position
   /lineheight fontsize def

   /font_normal /Times-Roman findfont fontsize scalefont def
   /font_bold /Times-Bold findfont fontsize scalefont def
   font_normal setfont
} def

/newline
 { currentpoint exch pop lineheight sub  % calc y-val
   BM lt                                 % check if less than bottom margin
   { showpage LM TM moveto               % New page
     /ypos TM def }
   { ypos lineheight sub                 % Go left/down
     /ypos exch def
     LM ypos moveto } ifelse
} def
   
/prtstr
 { dup stringwidth pop      % calc length of string
   currentpoint pop         % get horizontal position
   add RM gt                % sum > right margin?
   {newline} if             % if so, next line
   show 
} def

/setnormal { font_normal setfont } bind def
/setbold { font_bold setfont } bind def

%% ---- Utils ------

/min  %% int int -- int   | Return min of two ints
{
   2 copy gt { exch pop } { pop } ifelse
} bind def

/max  %% int int -- int   | Return max of two ints
{
   2 copy lt { exch pop } { pop } ifelse
} bind def

/append   %% array elem -- array with elem   | Append elem to array, returning a new array with result.
{
   1 index length dup 1 add array   % Create new larger array.
   dup 0 6 -1 roll putinterval      % Copy old array into new.
   dup 4 -2 roll                    % Duplicate array and stack roll.
   exch put                         % Put element to end.
} bind def


%% --- Step 1 ----------

/s1:init   %% dataset start_node -- 
{
   /start_node exch def
   /input exch def   
   /workarray 1000 array def

   /workarray_index -1 def
   start_node s1:push_node

   /memory 10000 dict def

   % Set up memory for stop node
   (out) 1 s1:inc_memory
} bind def


/s1:inc_memory  %% node amount --  | Increase value for node in memory. Create if necessary.
{
   /inc_amount exch def
   /inc_node exch def

   memory inc_node known
   {
      memory inc_node
      memory inc_node get inc_amount add
      put
   }
   {
      memory inc_node inc_amount put
   } ifelse
} bind def


/s1:push_node  %% node --    | Add node to workarray
{
   dup input exch get   % node leafs
   [ 3 -1 roll 0 4 -1 roll ]

   /workarray_index workarray_index 1 add def
   workarray workarray_index 3 -1 roll put
} bind def


/s1:pop_node %% --   | Pop current node
{
   /workarray_index workarray_index 1 sub def
} bind def



% Nodes: [(node) child_index [children]]
/NODE 0 def
/CHILD_INDEX 1 def
/CHILDREN 2 def 

/s1:iterate
{
   {
      workarray_index -1 eq { exit } if

      /current workarray workarray_index get def

      current aload pop
      /current_children exch def
      /current_child_index exch def
      /current_node exch def

      /current_child current_children current_child_index get def

      memory current_child known
      {
         % Existing node or end node (already added).
         memory current_child get
         current_node exch s1:inc_memory

         /current_child_index current_child_index 1 add def
         current CHILD_INDEX current_child_index put

         current_child_index current_children length 1 sub gt
         {
            % Instead of updating the parent this turn, just pop the node
            % and handle the new state next turn.
            s1:pop_node            
         } if
      }
      {
         % New node, push to work array.
         current_child s1:push_node
      } ifelse
   } loop
} bind def


%% --- Step 2 ----------

/s2:init   %% dataset start_node -- 
{
   /start_node exch def
   /input exch def   

   /workarray 1000 array def
   /workarray_index -1 def
   start_node false false s2:push_node

   /memory 10000 dict def

   /node_index input length 1 add dict def   % Index for node names to int (plus "out")
   s2:index_names

   /s2:result 0 def
} bind def


/s2:index_names
{
   /i 0 def
   input
   {
      pop
      node_index exch i put
      /i i 1 add def
   } forall

   node_index (out) i put
} bind def


% It is way too slow to index the memory on an array "[ node seen_fft seen_dac ]".
% Instead I first, during init, index all names to a unique int, in dict "node_index".
% The keys here are stored as "index << 2 | seen_fft << 1 | seen_dac", where index
% is the index looked up from the node->index dict.

/s2:make_key   %% node seen_fft seen_dac -- key (int)  | Make key for memory from input
{
   node_index 4 -1 roll get        % seen_fft seen_dac node_index
   2 mul                           % seen_fft seen_dac node_index*2 
   3 -1 roll {1} {0} ifelse add    % seen_dac sum 
   2 mul                           % seen_dac sum*2
   exch {1} {0} ifelse add         % sum 
} bind def


/s2:push_node  %% node seen_fft seen_dac --    | Add node to workarray
{
   /seen_dac exch def
   /seen_fft exch def
   /pnode exch def
   % (Pushing: ) print pnode println
   
   /pchildren pnode (out) eq
   { [] }                           % "out" has no children.
   { input pnode get } ifelse def   % normal children.

   [ pnode 0 pchildren seen_fft seen_dac 0 ]

   /workarray_index workarray_index 1 add def
   workarray workarray_index 3 -1 roll put
} bind def


/s2:pop_node %% --   | Pop current node
{
   % (current pop: ) print current NODE get =
   /workarray_index workarray_index 1 sub def
} bind def


% Nodes: [(node) child_index [children] seen_fft seen_dac]
/NODE 0 def
/CHILD_INDEX 1 def
/CHILDREN 2 def
/SEEN_FFT 3 def
/SEEN_DAC 4 def
/SUM 5 def

/s2:add_to_parent_sum   %% value --   | Add value to parent sum
{
   workarray_index 0 gt
   {
      /parent workarray workarray_index 1 sub get def
      parent SUM get add parent SUM 3 -1 roll put
   }
   {
      /s2:result exch def
   } ifelse
} bind def


/s2:iterate
{
   {
      % Exit on stack empty
      workarray_index -1 eq { exit } if

      /current workarray workarray_index get def

      current NODE get (out) eq
      {
         % Handle (out) - end of search.
         current SEEN_FFT get current SEEN_DAC get and
         {
            /return_value 1 def
         }
         {
            /return_value 0 def
         } ifelse

         /key current NODE get current SEEN_FFT get current SEEN_DAC get s2:make_key def
         memory key return_value put
            
         return_value s2:add_to_parent_sum
         s2:pop_node
      }
      {
         % Handle key known.
         /key current NODE get current SEEN_FFT get current SEEN_DAC get s2:make_key def

         memory key known
         {
            memory key get s2:add_to_parent_sum
            s2:pop_node
         }
         {
            current CHILD_INDEX get current CHILDREN get length lt
            {
               % Push child.
               /child current CHILDREN get current CHILD_INDEX get get def
               current CHILD_INDEX current CHILD_INDEX get 1 add put

               /f2 current SEEN_FFT get child (fft) eq or def
               /d2 current SEEN_DAC get child (dac) eq or def
               child f2 d2 s2:push_node
            }
            {
               % No more children, pop.
               current SUM get
               dup memory key 3 -1 roll put
               s2:add_to_parent_sum
               s2:pop_node
            } ifelse
         } ifelse
      } ifelse
   } loop
} bind def


%% ------------------------------

setup_output

input_data (you) s1:init
s1:iterate
/result_step_1 memory (you) get def

input_data (svr) s2:init
s2:iterate
/result_step_2 s2:result def


% Output to paper
LM TM moveto
setbold (Advent of Code 2025) prtstr setnormal newline newline
(- Day 11 -) prtstr 1 1 6 { pop newline } for
setbold (Result step 1: ) prtstr setnormal result_step_1 100 string cvs prtstr newline newline
setbold (Result step 2: ) prtstr setnormal result_step_2 100 string cvs prtstr newline

% Write to stdout as well
(\nAdvent of Code 2025  - Day 11 - Anders Piniesjö\n) println 
(Result step 1: ) print result_step_1 20 string cvs println
(Result step 2: ) print result_step_2 20 string cvs println
